---
layout : post
permalink : /content/xml-as-intermediate-application-layer/index.html
author : "Pascal Opitz"
author_id : 1
title : "XML as intermediate application layer"
date : "2005-05-31 08:37:12"
dateformatted : "May 31 2005, 08:37"
excerpt : |
    <p>Why not keeping the application logic just working with XML and benefit from robust toolkits and neat techniques rather than changing HTML-markup in PHP-code?</p>
categories : 
   - May 2005
   - "Pascal Opitz"
---

<h2>Why bothering?</h2>

<p>Dealing with any server-side scripting language the things that I find most annyoing are the ones where I have to change 

	<br />

	<code class="inline"> echo '&lt;a href="' . $url . '"&gt;' . $text . '&lt;/a&gt;&lt;br /&gt;';</code>

	<br />
	to something like 
	<br />

	<code class="inline"> echo '&lt;li&gt;&lt;a href="' . $url . '"&gt;' . $text . '&lt;/a&gt;&lt;/li&gt;';</code>
	</p>

<p>It's always a waste of time, and often, due to some typo, errors sneak in and suddenly you're debugging again.</p>
	

<p>In this article I want to share my thoughts on techniques for keeping our code XML-based - so there's no need to get your hands dirty in your application code to change the markup that is rendered afterwards. Most things will be PHP related though.
</p>


<h2>Other benefits</h2>

<p>Once we get the seperation working properly, we can completely detach the development of front end from the application logic by first agreeing on an XML scheme to exchange data between those two.</p>

<p>By providing dummy XML to the guy doing the XHTML and CSS he can flesh everything out and then put it into an XSLT. Even before the application is built he can have finished everything... Then to get up and running, just the XSLT files, images and CSS need to be dropped in. Good to go.</p>

<p>By keeping the dataflow of the application logic stricly XML compliant we also have no problems using the same code 
	for outputting a different version, to mobile devices, for example, OR to swap the data-source with an external web-service. </p>

<p>And did I mention that suddenly you can work with UTF-8 throughout the whole application and the XSLT automatically 
transforms it into the needed output format? You just need the right parser.</p>

<p>On top of all that, we are using a w3c technique and have the ability to render tree structures and stuff...</p>


<h2>A 5 layer approach</h2>

<p>
	The <a href="http://www.graphicpush.com/archives/000070.shtml">3 layer paradigm</a> has been around for a while and most of you probably are familliar with it.</p>
	
<p>I mostly agree but for our needs, just half of the job is covered. That's why I want to extend it into a 5 layer approach.
</p>
	
<p><img src="http://www.contentwithstyle.co.uk/resources/old_images/15.gif" alt="5 layer approach" longdesc="This graphic shows 5 layers of a web-application as follows: XML: Application data output, XSL: Transformation for target platform, (X)HTML: Markup - Client side, CSS: Presentation - Client side, Javascript: Behaviour" />
</p>


<h2>Planning your application</h2>

<p>First of all you obviously need to flesh out what the application does etc. and which part does what.</p>
	
<p>We should also take care of the platform that we'll be developing for, to avoid facing the worst of all situations: having to throw the whole goddam thing in the bin and start from scratch.</p>
	
<p>Then, like I already mentioned, we can work out the output XML structure and pass it on to the front end developer. As soon as that's done we can move on to plan the code for our application.
</p>


<h2>Structuring the application code</h2>
		
<p>Now that we know what needs to be done we can assemble a robust set of classes, either the <a href="http://pear.php.net/">PEAR</a> ones or custom ones (I tend to use custom ones) that perform several actions for us:
</p>

<dl>
	<dt>General DB class</dt>
	<dd>
		A class that gives us easy access to our database and returns resultsets or arrays, manages updates and inserts and explains
		tables and all that ... 
		<br />
		If you're working with several database-types I'd recommend to <a href="http://www.jakober.ch/asp/asp_ado.php">make use of 
		ADO in ASP</a>, and there is an <a href="http://adodb.sourceforge.net/">ADODB toolkit for PHP</a> as well.
	</dd>
	
	<dt>Database output to XML</dt>
	<dd>
		It's a very simple thing, but it makes life very comfortable. I use my own one in PHP, but 
		<a href="http://pear.php.net/package/XML_sql2xml" title="PEAR::XML_sql2xml">there is a PEAR class for this</a> 
		as well.
	</dd>
	
	<dt>XSLT transformation class</dt>
	<dd>
		This class should manage to process XML input by using XSL files. And again, 
		<a href="http://pear.php.net/package/XML_XSLT_Wrapper#results" title="PEAR::XML_XSLT_Wrapper">there is a PEAR class for doing
		this</a>.
	</dd>
</dl>

<p>Obviously it's down to the developer to add more classes for specific problems, but once we have gathered our basic toolkit
we can think about ways to transform things easily.</p>


<h2>Class based application</h2>

<p>I highly recommend taking a big big step back from procedural scripting. Instead you can work out a class structure and 
	write rendering methods for either the page or parts of the page. Again, classes are robust and reusable. If you are unfamiliar with
	<a href="http://en.wikipedia.org/wiki/Object-oriented_programming" title="Object-oriented Programming">OOP</a> in PHP, 
	<a href="http://www.informit.com/articles/article.asp?p=24607&amp;rl=1" title="A Quick and Dirty Introduction to OOP with PHP">make
	 yourself familiar with it</a> ASAP.
</p>


<h2>PHP - output buffering</h2>

<p>And here comes one of the nicest ideas ever.</p>
	
<p>I think that <a href="http://www.zend.com/zend/art/buffering.php">output buffering</a> is a handy thing anyway. And there are <a href="http://www.jinxidoru.com/_php/buffering.html">many ways to benefit from it</a>. But the coolest feature though is the callback function.</p>
	
<p>Instead of having a method called by something to finally get the XHTML out of our application, we just process the whole output
generated in PHP with this single callback funtion. Some flags can trigger which XSLT to use. </p>

<p>And there we are, <strong>we have a strictly XML based internal dataflow, but rendered HTML in the output</strong>.</p>


<h2>Outlook</h2>

<p>I hope everyone sees the point of my approach and how you can work out a robust application. I also hope everyone understands why I didn't provide much code this time,
since it would be quite a lot of code and still be platform specific.
</p>
	
<p>Using output buffering may seem a bit like a loss of control, since you cannot pass parameters to the callback function, but it makes sense to just call one XSL and, similar to use @import in CSS, include XSL files for patricular elements. How to do that will be the next topic, so stay tuned.</p>
---
layout : post
permalink : /content/processing-the-output-buffer-with-xslt/index.html
author : "Pascal Opitz"
author_id : 1
title : "Processing the output buffer with XSLT"
date : "2005-07-24 18:07:12"
dateformatted : "July 24 2005, 18:07"
excerpt : |
    <p>
    This article shows an example of a technique mentioned in one of our recent articles. 
    It uses the PHP output buffer in combination with <a href="http://www.contentwithstyle.co.uk/Articles/29/xml-as-intermediate-application-layer/" title="XML as intermediate application layer">XML as intermediate application layer</a>.
    Ideally you should familiarize yourself with this concept first.
    </p>
categories : 
   - July 2005
   - "Pascal Opitz"
---

<h2>The output buffer</h2>

<p>
Most programmers dealing with PHP will have come across various PHP errors when trying to do a redirect after an echo
or something similar.
</p>

<p>
The error usually looks like this:
</p>

<pre>
Warning: Cannot add header information - headers already sent by
(output started at /directory/to/starting_file.php:XXX) 
    in /directory/to/calling_file.php on line XX
</pre>

<p>
And for many of you that will have been the only application for the function <a href="http://uk2.php.net/manual/de/function.ob-start.php">ob_start</a>
which immediately fixes exactly these errors.
But most ignore that <em>ob_start</em> is just one function of a whole toolkit of functions that are referred to as <a href="http://uk2.php.net/manual/en/ref.outcontrol.php">&#8220;Output Control Functions&#8221;</a>, 
which provide a sophisticated toolkit for controlling and manipulating the output generated by PHP.
</p>

<h2>The callback function</h2>

<p>
The most powerful bit in this set of functions is definitely <em>ob_start</em> and it's optional parameter, the callback function.
This callback function will be called when the output is finally thrown. Using this it's easy to generate output and, for example, clean it afterwards with
HTML tidy, escape it, replace parts of it or replace all of it.
</p>

<p>
To show what I mean I'll provide a little class-based script as an example:
</p>

<pre>
&lt;?
class examplePage
{
  function examplePage()
  {
    ob_start(array($this,'parseOutput'));
    echo $this-&gt;getExampleXML();
  }

  function parseOutput()
  {
    $str = "&lt;pre&gt;" . htmlentities(ob_get_contents()) . 
        "&lt;/pre&gt; is the XML string we get from getExampleXML()";
    return $str;
  }  
  

  function getExampleXML()
  {
    $str = "&lt;root&gt;&lt;test&gt;Teststring&lt;/test&gt;&lt;/root&gt;";
    return $str;
  }
}

$example = new examplePage();

?&gt;
</pre>

<p>
As you can see the content thrown by the echo is parsed afterwards by the <em>parseOutput</em> method, and stuff gets added and escaped in one go.
</p>



<h2>Layered applications</h2>

<p>
This alone is a very powerful tool that can be used in pretty much every application that generates output with PHP, but we can push  it one step further. 
</p>

<p>
We'll use <em>XML as an intermediate application layer</em>.
The callback function will then process the whole output and render it through an XSL transformation.
</p>

<pre>
&lt;?
class examplePage
{
  function examplePage()
  {
    ob_start(array($this,'parseOutput'));
    echo $this-&gt;getExampleXML();
  }

  function parseOutput()
  {
    $this-&gt;xslt = xslt_create();

    $this-&gt;arguments['/_xml'] = ob_get_contents();
    $this-&gt;xmlDoc = 'arg:/_xml';


    $this-&gt;arguments['/_xsl'] = $this-&gt;getExampleXSL();
    $this-&gt;xslDoc = 'arg:/_xsl';

    return xslt_process($this-&gt;xslt, $this-&gt;xmlDoc, 
                    $this-&gt;xslDoc, NULL, $this-&gt;arguments);
  }  
  

  function getExampleXML()
  {
    $str = "&lt;root&gt;&lt;test&gt;Teststring&lt;/test&gt;&lt;/root&gt;";
    return $str;
  }


  function getExampleXSL()
  {
    $str = '&lt;?xml version="1.0" encoding="utf-8"?&gt;
      &lt;xsl:stylesheet version="1.0" 
	  	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt; 
      
      &lt;xsl:template match="/"&gt;
        Test: &lt;xsl:value-of select="//test" /&gt;
      &lt;/xsl:template&gt; 
       
      &lt;/xsl:stylesheet&gt;
    ';

    return $str;
  }
}

$example = new examplePage();

?&gt;
</pre>

<p>
And here we go - dynamic processing of the XML-based application output.
This is obviously a raw example, and it needs integration in whatever framework you use, but hopefully you can see the power and flexibility of this technique.
</p>


<h2>Outlook</h2>

<p>
So what could this be useful for?
</p>
<p>
In my opinion this could give some web applications a whole new twist. One possibility for the techniques described 
would be to separate the presentation-related rendering process
into the step after the output. While your application is built to render XML and throw that into the PHP output, 
a separate method, maybe even a separate class, could handle this output and transform it into the right format.
</p>
<p>
The advantages are immediately obvious. Output rendering would become a reusable module and without it the application would
still output W3C-compliant XML code (<em>if you did everything right, that is</em>).
</p>

<p>
And again, this is just one possibility to use the callback function. Together with regular expressions or applications like
<a href="http://tidy.sourceforge.net/">Tidy</a> you could ensure that the output of dynamic data is valid. This could be useful for all people
who use variables to pass html-content into XSL templates.
</p>